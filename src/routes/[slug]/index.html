<!--
Copyright (C) 2020 bonome

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->
<script context="module">
// TODO 
// add label on selected event 
// add on-call computing for each user 
// since the beginning until the end of this week or the end last displayed week
// disabled days between the first day of the week of start_date of planning and the start_date of the planning
// + some little things :)
    import { startOfWeek, eachDayOfInterval, getDay } from 'date-fns';
    export async function preload(page) {
        const {slug} = page.params;

        const response = await this.fetch('planning/' + slug + '.json', {method: 'get'});
        const data = await response.json();
        let users = data.users;
        let days = data.week.days;
        let firstDayOfTheWeek = data.week.dayOne;
        let disabledDays = data.week.disabled;
        let events = data.events;
        let processed = data.processed;
        let planning_number_week_displayed = data.number_week_displayed;

        let penultimateWeek = subWeeks(startOfWeek(new Date(), {weekStartsOn: firstDayOfTheWeek}), 1);
        if (compareAsc(parseISO(data.start_date), penultimateWeek) === 1) {
            // penultimateWeek date is older than the beginning of the planning
            penultimateWeek = startOfWeek(parseISO(data.start_date), {weekStartsOn: firstDayOfTheWeek});
        }
        let lastDisplayedDate = addWeeks(endOfWeek(penultimateWeek, {weekStartsOn: firstDayOfTheWeek}), planning_number_week_displayed);
        lastDisplayedDate = new Date(lastDisplayedDate.getTime() - (lastDisplayedDate.getTimezoneOffset() * 60000));
        if (compareAsc(lastDisplayedDate, parseISO(data.week.disabledStored)) === 1) {
            // date of the disabled day stored in db is older than the last of the last week displayed

            var daysDisplayedToProcessed = eachDayOfInterval({
                start: parseISO(data.week.disabledStored),
                end: lastDisplayedDate
            });

            let disablingDays = {
                dates: [],
                lastProcessed: lastDisplayedDate
            }
            for (let i = 0; i < daysDisplayedToProcessed.length; i++) {
                let normalizeDate = new Date(daysDisplayedToProcessed[i].getTime() - (daysDisplayedToProcessed[i].getTimezoneOffset() * 60000));
                if (disabledDays.indexOf(getDay(daysDisplayedToProcessed[i])) >= 0) {

                    disablingDays.dates.push({date: normalizeDate, type: -1});
                }

                if (data.off[normalizeDate.toISOString()] != null) {
                    disablingDays.dates.push({date: normalizeDate, type: -2, comment: data.off[normalizeDate.toISOString()]});
                }
            }
            await this.fetch('planning/' + slug + '/disablingdays.json', {
                method: 'post',
                headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(disablingDays)
            });
        }
        const resDays = await this.fetch('planning/' + slug + '/days.json', {method: 'get'});
        const rawDataDays = await resDays.json();
        let dataDays = {};
        for (let idx = 0; idx < rawDataDays.length; idx++) {
            if (dataDays[rawDataDays[idx].date] == null) {
                dataDays[rawDataDays[idx].date] = {};
            }
            dataDays[rawDataDays[idx].date][rawDataDays[idx].user] = {
                type: rawDataDays[idx].type,
                _id: rawDataDays[idx]._id
            }
        }

        return {users, days, firstDayOfTheWeek, dataDays, slug, events, processed, penultimateWeek, planning_number_week_displayed};
    }
</script>
<script>
    import { onMount } from 'svelte';
    import io from 'socket.io-client';
    import { endOfWeek, subWeeks, addWeeks, parseISO, compareAsc } from 'date-fns';

    import { selected_event, number_week_displayed } from '../../store.js';
    import { conf } from '../../conf.js';
    import Month from '../../components/Month.html';

    export let slug;
    export let days = [];
    export let firstDayOfTheWeek;
//    export let disabledDays = [];
    export let users = [];
    export let dataDays = [];
    export let events;
    export let processed;
    export let penultimateWeek;
    export let planning_number_week_displayed;
    let defaultType = 1;//oncalled

    $selected_event = defaultType;
    $number_week_displayed = planning_number_week_displayed;


    const socket = io();

    socket.on('connect', function () {
        socket.emit('join', slug);
    });

    onMount(async function () {
        let lastDayOfLastWeek = subWeeks(endOfWeek(new Date(), {weekStartsOn: firstDayOfTheWeek}), 1);

        let last_processed = parseISO(processed.oncalled.last_updated_at);

        let cmp = compareAsc(lastDayOfLastWeek, last_processed);
        if (cmp === 1) {
            // last_processed date is older than last day of last week so reprocessing

            const response = await fetch('planning/' + slug + '/process.json', {
                method: 'post',
                headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({lastDayOfLastWeek: lastDayOfLastWeek, type: 1})
            });
            let data = await response.json();
            for (let k = 0; k < data.length; k++) {
                let _id = data[k]._id;
                if (processed.oncalled.users[_id] == null) {
                    processed.oncalled.users[_id] = {todo: 0, done: 0}
                }
                processed.oncalled.users[_id].done = data[k].count;
            }
            processed.oncalled.last_updated_at = lastDayOfLastWeek;
        } else {
            console.log('nothing to do, to processed numbers of doing of each user...');
        }

    });

    socket.on('day', (day) => {
        if (dataDays[day.date] == null) {
            dataDays[day.date] = {};
        }
        dataDays[day.date][day.user] = {
            type: day.type,
            _id: day._id
        }
    });

    const defaultEventClick = event_type => () => {
            selected_event.set(event_type);
        };
</script>

<svelte:head>
    <title>Planning</title>
</svelte:head>
<div class="side-infos">
    <div class='events-selection'>
        {#each events as event, i}
        <div>
            <span 
                on:click={defaultEventClick(event.type)}
                class="cell day day-evt-{event.type}"
                class:selected="{event.type === $selected_event}">
            </span>
            <span class="label">
                {event.name}
            </span>
        </div>
        {/each}
    </div>
    <div class="processed">
        {#each Object.keys(processed.oncalled.users) as user_id}
        <div>
            <b>{users.find(x=> x.id == user_id).name}</b>: 
            <p>todo: {processed.oncalled.users[user_id].recommended}</p>
            <p>done: {processed.oncalled.users[user_id].done} </p>
        </div>
        {/each}
    </div>
</div>
{#if days.length > 0 }
<Month {users} {firstDayOfTheWeek} {days} {dataDays} {slug} {socket} {penultimateWeek}></Month>
{/if}

<style>
    .day {
        border: 3px solid transparent;  
    }
    .selected {
        border: 3px solid red;  
    }
    .side-infos {
        position: fixed;
        left: 10px;
    }
    .processed {
        margin-top: 20px;
        line-height: 0.5;
    }
    @media (max-width: 1200px) {
        .side-infos {
            width: 100px;
        }
    }
    @media (max-width: 1050px) {
        .side-infos {
            left: 150px;
            top: 0px;
            z-index: 1050;
            width: 70%;
        }
        .side-infos .events-selection div{
            display: inline-block;
            width: 100px;
        }
        .processed {
            display: none;
        }
    }
    @media (max-width: 750px) {
        .side-infos .events-selection .label{
            display: none;
        }
        .side-infos .events-selection div{
            width: 20%;
        }
        .side-infos .events-selection .day{
            width: 90%;
        }
    }
</style>